import { spawn } from 'child_process';

export const UNCOMMITTED = '*';
export const UNABLE_TO_FIND_GIT_MSG =
  'Unable to find a Git executable. Either: Set the Visual Studio Code Setting "git.path" to the path and filename of an existing Git executable, or install Git and restart Visual Studio Code.';

/* Path Manipulation */

const EOL_REGEX = /\r\n|\r|\n/g;
const FS_REGEX = /\\/g;

/**
 * Get the normalised path of a string.
 * @param str The string.
 * @returns The normalised path.
 */
export function getPathFromStr(str: string) {
  return str.replace(FS_REGEX, '/');
}

/* Promise Methods */

/**
 * Evaluate promises in parallel, with at most `maxParallel` running at any point in time.
 * @param data The array of elements to be mapped via promises.
 * @param maxParallel The maximum number of promises to run at any point in time.
 * @param createPromise A function that creates a promise from an element of `data`.
 * @returns A result array evaluated by mapping promises generated from `data`.
 */
export function evalPromises<X, Y>(
  data: X[],
  maxParallel: number,
  createPromise: (val: X) => Promise<Y>
) {
  return new Promise<Y[]>((resolve, reject) => {
    if (data.length === 1) {
      createPromise(data[0])
        .then((v) => resolve([v]))
        .catch(() => reject());
    } else if (data.length === 0) {
      resolve([]);
    } else {
      const results: Y[] = new Array(data.length);
      let nextPromise = 0;
      let rejected = false;
      let completed = 0;
      // eslint-disable-next-line no-inner-declarations
      function startNext() {
        const cur = nextPromise;
        nextPromise++;
        createPromise(data[cur])
          .then((result) => {
            if (!rejected) {
              results[cur] = result;
              completed++;
              if (nextPromise < data.length) startNext();
              else if (completed === data.length) resolve(results);
            }
          })
          .catch(() => {
            reject();
            rejected = true;
          });
      }
      for (let i = 0; i < maxParallel && i < data.length; i++) startNext();
    }
  });
}

/**
 * Produce a suitable error message from a spawned Git command that terminated with an erroneous status code.
 * @param error An error generated by JavaScript (optional).
 * @param stdoutBuffer A buffer containing the data outputted to `stdout`.
 * @param stderr A string containing the data outputted to `stderr`.
 * @returns A suitable error message.
 */
function getErrorMessage(error: Error | null, stdoutBuffer: Buffer, stderr: string) {
  const stdout = stdoutBuffer.toString();
  let lines: string[];
  if (stdout !== '' || stderr !== '') {
    lines = (stderr + stdout).split(EOL_REGEX);
    lines.pop();
  } else if (error) {
    lines = error.message.split(EOL_REGEX);
  } else {
    lines = [];
  }
  return lines.join('\n');
}

export async function spawnGitRaw<T>(
  repo: string,
  args: readonly string[],
  resolveValue: (stdout: Buffer, stderr: string) => T
): Promise<T> {
  const cmd = spawn('git', args, { cwd: repo, env: { ...process.env } });
  const stdoutReadable = cmd.stdout;
  const stderrReadable = cmd.stderr;
  if (stdoutReadable == null || stderrReadable == null) throw new Error();
  const [status, stdout, stderr] = await Promise.all([
    new Promise<{ code: number | null; error: Error | null }>((resolve) => {
      // status promise
      let resolved = false;
      cmd.on('error', (error) => {
        if (resolved) return;
        resolve({ code: -1, error });
        resolved = true;
      });
      cmd.on('exit', (code) => {
        if (resolved) return;
        resolve({ code, error: null });
        resolved = true;
      });
    }),
    new Promise<Buffer>((resolve) => {
      // stdout promise
      const buffers: Buffer[] = [];
      stdoutReadable.on('data', (b: Buffer) => {
        buffers.push(b);
      });
      stdoutReadable.on('close', () => resolve(Buffer.concat(buffers)));
    }),
    new Promise<string>((resolve) => {
      // stderr promise
      let stderrString = '';
      stderrReadable.on('data', (d) => {
        stderrString += d;
      });
      stderrReadable.on('close', () => resolve(stderrString));
    }),
  ]);
  if (status.code === 0) {
    return resolveValue(stdout, stderr);
  } else {
    throw getErrorMessage(status.error, stdout, stderr);
  }
}
