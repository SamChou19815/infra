// @generated
/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-monorail",
factory: function (require) {
var plugin=(()=>{var H=Object.create;var m=Object.defineProperty,M=Object.defineProperties,q=Object.getOwnPropertyDescriptor,B=Object.getOwnPropertyDescriptors,U=Object.getOwnPropertyNames,g=Object.getOwnPropertySymbols,V=Object.getPrototypeOf,S=Object.prototype.hasOwnProperty,E=Object.prototype.propertyIsEnumerable;var I=(e,n,r)=>n in e?m(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r,y=(e,n)=>{for(var r in n||(n={}))S.call(n,r)&&I(e,r,n[r]);if(g)for(var r of g(n))E.call(n,r)&&I(e,r,n[r]);return e},P=(e,n)=>M(e,B(n)),$=e=>m(e,"__esModule",{value:!0});var k=(e=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(e,{get:(n,r)=>(typeof require!="undefined"?require:n)[r]}):e)(function(e){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var b=(e,n)=>{var r={};for(var t in e)S.call(e,t)&&n.indexOf(t)<0&&(r[t]=e[t]);if(e!=null&&g)for(var t of g(e))n.indexOf(t)<0&&E.call(e,t)&&(r[t]=e[t]);return r};var z=(e,n)=>{$(e);for(var r in n)m(e,r,{get:n[r],enumerable:!0})},K=(e,n,r)=>{if(n&&typeof n=="object"||typeof n=="function")for(let t of U(n))!S.call(e,t)&&t!=="default"&&m(e,t,{get:()=>n[t],enumerable:!(r=q(n,t))||r.enumerable});return e},w=e=>K($(m(e!=null?H(V(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var oe={};z(oe,{default:()=>te});var _=w(k("fs")),x=w(k("clipanion"));var d=e=>process.stderr.isTTY?n=>`[${e}m${n}[0m`:n=>n,ae=d(31),F=d(32),X=d(33),A=d(34),R=d(35),v=d(36),Z=["\u280B","\u2819","\u2839","\u2838","\u283C","\u2834","\u2826","\u2827","\u2807","\u280F"];async function J(e,n){if(!process.stderr.isTTY)return n();let r=0,t=new Date().getTime(),s=setInterval(()=>{let o=`${((new Date().getTime()-t)/1e3).toFixed(1)}s`,a=e(o),c=Z[r%10];process.stderr.write(X(`${a} ${c}\r`)),r+=1},process.stderr.isTTY?40:1e3),i=await n();return clearInterval(s),i}var D=w(k("child_process"));function l(e,n,r){let t=(0,D.spawn)(e,n,{shell:!0,cwd:r,stdio:["ignore","pipe","pipe"]}),s="";return t.stdout.on("data",i=>{s+=i.toString()}),t.stderr.on("data",i=>{console.error(i.toString())}),new Promise(i=>{t.on("close",o=>{i({success:o===0,stdout:s})})})}var L=w(k("fs/promises"));function j(e){return e.scope==null?e.name:`@${e.scope}/${e.name}`}function Q(e){let n=new Map;return e.workspaces.forEach(r=>{let t=r.relativeCwd;if(t===".")return;let s=j(r.locator),i=Array.from(r.getRecursiveWorkspaceDependencies()).map(o=>j(o.locator));n.set(s,{workspaceLocation:t,dependencies:i})}),n}function N(e,n){let r=[],t=[],s=new Set,i=new Set;function o(a){var p;if(i.has(a)){if(!s.has(a))return;t.push(a);let f=t.indexOf(a),G=t.slice(f,t.length).join(" -> ");throw new Error(`Cyclic dependency detected: ${G}`)}let c=(p=e.get(a))==null?void 0:p.dependencies;if(c==null)throw new Error(`Workspace ${n} is not found!`);i.add(a),t.push(a),s.add(a),c.forEach(o),s.delete(a),t.pop(),r.push(a)}return o(n),r}function O(e){let n=Q(e);return{__type__:"@generated",information:Object.fromEntries(Array.from(n.entries()).map(i=>{var[r,o]=i,a=o,{dependencies:t}=a,s=b(a,["dependencies"]);return[r,P(y({},s),{dependencyChain:N(n,r)})]}).sort(([r],[t])=>r.localeCompare(t))),topologicallyOrdered:(()=>{let r=[],t=new Set;return Array.from(n.keys()).forEach(s=>{N(n,s).forEach(o=>{t.has(o)||(r.push(o),t.add(o))})}),r})()}}async function h(){let e=await(0,L.readFile)("workspaces.json");return JSON.parse(e.toString())}async function ee(e){async function n(r,t){let s=(await l("git",["diff",r,...t?[t]:[],"--name-only","--",e])).stdout.toString().trim();return s===""?[]:s.split(`
`)}return process.env.CI?n("HEAD^","HEAD"):n("origin/main")}async function ne(e,n){var s,i;let r=(i=(s=e.information[n])==null?void 0:s.dependencyChain)!=null?i:[];return(await Promise.all(r.map(async o=>{var p,f;let a=(f=(p=e.information[o])==null?void 0:p.workspaceLocation)!=null?f:".";return(await ee(a)).length>0}))).some(o=>o)}async function u(){let e=await h();return await l("git",["add","."]),(await Promise.all(e.topologicallyOrdered.map(async r=>{let t=await ne(e,r);return[r,t]}))).filter(([,r])=>r).map(([r])=>y({name:r},e.information[r]))}async function C(e){let n=await u();n.forEach(({name:o})=>{console.error(A(`[i] Need to run \`${e}\` on workspace \`${o}\`.`))});let r=n.length,s=(await J(o=>`[?] Running command on ${r===1?"1 workspace":`${r} workspaces`} (${o})`,()=>Promise.all(n.map(async({name:o})=>{let{success:a,stdout:c}=await l("yarn",["workspace",o,e]);return r-=1,[o,a,c]})))).filter(o=>!o[1]),i=s.map(([o,,a])=>`${v(`> yarn workspace ${o} ${e}`)}
${a}
`).join("");return s.length===0?(console.error(F("[\u2713] All commands have finished successfully.")),!0):(console.error(R("[!] Some commands finished with errors.")),console.error(),console.error(i.trim()),!1)}var W=class extends x.Command{async execute(){return await C("compile")?0:1}};W.paths=[["c"]];var Y=class extends x.Command{async execute(){try{let n=await h();return this.context.stdout.write(`${JSON.stringify(n,void 0,2)}
`),0}catch{return 1}}};Y.paths=[["q"],["query"]];var T=class extends x.Command{async execute(){return this.context.stdout.write(`${JSON.stringify(await u(),void 0,2)}
`),0}};T.paths=[["t"],["targets"]];var re={hooks:{afterAllInstalled(e){(0,_.writeFileSync)("workspaces.json",`${JSON.stringify(O(e),void 0,2)}
`)}},commands:[W,Y,T]},te=re;return oe;})();
return plugin;
}
};
